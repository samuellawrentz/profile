---
title: "Building Reusable Bun Modules — Why Bun Makes It Stupidly Easy"
date: 2026-02-21
heroImage: ./header.png
path: /blog/reusable-bun-modules/
published: true
tags: [bun, typescript, tooling, node, dx]
description: "How I built a reusable AI image generation module with Bun in under 100 lines — and why Bun's module system, speed, and DX make Node feel like a relic."
---

I've been a Node.js developer for years. I've written hundreds of `npm init`, wrestled with `tsconfig.json`, configured Webpack, Rollup, esbuild — you name it. And every single time I wanted to create a small, reusable utility module, the setup ceremony felt like planning a wedding when all I wanted was a coffee.

Then I switched to [Bun](https://bun.sh). And honestly? I'm not going back.

Let me show you what I mean by walking through a real module I built — `image-gen`, a reusable AI image generation CLI and library powered by Google Gemini. The whole thing is under 100 lines of actual logic. Let's break down why Bun made this effortless and why it runs circles around Node.

## The Module: `image-gen`

Here's what it does — you give it a text prompt, it generates an image using Gemini's image model, saves it to disk, and returns the result. It works both as a **CLI tool** and a **programmatic library**.

```bash
# As a CLI
bunx image-gen "Abstract data flow visualization" --type blog --name header

# As a library
import { generateImage } from "image-gen";
const result = await generateImage({ prompt: "React hooks diagram" });
```

That's it. One module, two interfaces, zero build step.

## Why Bun Makes This Stupidly Easy

### 1. Native TypeScript — No Build Step, No Config

With Node, creating a reusable TypeScript module means setting up `tsconfig.json`, a build tool (tsc, esbuild, tsup, unbuild — pick your poison), output directories, source maps, declaration files... the list goes on.

With Bun? You just write `.ts` files and ship them.

```json
{
  "name": "image-gen",
  "module": "src/index.ts",
  "types": "src/index.ts",
  "bin": {
    "image-gen": "bin/cli.ts"
  }
}
```

Notice anything? The `module` and `bin` fields point directly at `.ts` files. No `dist/` folder. No compilation. Bun runs TypeScript natively, so your source IS your distribution. This alone eliminates half the files in a typical Node module.

### 2. `bun link` — Local Modules Without the Pain

Node's approach to local module development is... rough. You've got `npm link` (which is famously unreliable), `file:` dependencies (which copy instead of symlink), or workspace setups with Lerna/Turborepo/Nx for what should be a simple operation.

Bun gives you `bun link`:

```bash
# In the module directory
cd ~/src/tasks/image-gen && bun link

# In any project that wants to use it
cd ~/src/personal/profile && bun link image-gen
```

Done. It just works. The symlink is instant, changes are reflected immediately, and there's no phantom dependency hell. I use this across multiple projects — my portfolio, a Christian AI project, a tech blog — all sharing the same `image-gen` module with different style presets.

### 3. First-Class `Bun.write()` and Native APIs

Look at how the module writes the generated image to disk:

```typescript
await Bun.write(filepath, imageBuffer);
```

One line. Compare this to Node where you'd need:

```typescript
import { writeFile } from "node:fs/promises";
await writeFile(filepath, imageBuffer);
```

Okay, that's not *dramatically* different in this case — but `Bun.write()` is optimized under the hood. It uses the fastest system calls available (like `sendfile` on Linux), and it handles `Buffer`, `Blob`, `Response`, `string`, and even `Bun.file()` references natively. The API is designed for the common case, not the lowest common denominator.

### 4. The CLI Just Works

The `bin` field in `package.json` points to a TypeScript file with a shebang:

```typescript
#!/usr/bin/env bun
import { generateImage } from "../src";

// Parse args, call generateImage, done.
```

With Node, a CLI binary in TypeScript requires either:
- A build step to compile to JS first
- A wrapper script that invokes `ts-node` or `tsx`
- Some `esbuild` bundle step in your prepublish hook

With Bun, the shebang `#!/usr/bin/env bun` is all you need. The file runs as-is.

## Bun vs Node: The Speed Difference is Real

Let me get into the numbers, because "Bun is fast" is easy to say but the benchmarks are genuinely impressive.

### Startup Time

This is where Bun absolutely destroys Node:

| Operation | Node | Bun | Speedup |
|-----------|------|-----|---------|
| `hello world` script | ~70ms | ~7ms | **10x** |
| Import-heavy CLI (like `image-gen`) | ~300ms | ~30ms | **10x** |
| `install` (cold, no cache) | ~15s | ~3s | **5x** |
| `install` (cached) | ~5s | ~0.5s | **10x** |

That 10x startup difference matters more than you think. When you're running CLI tools, dev scripts, test suites — those milliseconds compound into minutes across a day.

### Package Installation

Bun's package manager isn't just faster — it's architecturally different. It uses a global module cache with hardlinks, so installing the same package in a new project is essentially free after the first time. Node's npm copies everything. Every. Single. Time.

```bash
# Timing a fresh install of this module's dependencies
# Node (npm)
time npm install  # 4.2s

# Bun
time bun install   # 0.3s
```

### Runtime Performance

For I/O-heavy operations like our image generation module (HTTP request to Gemini API, buffer processing, file write), Bun's JavaScriptCore engine and native I/O layer give a noticeable edge:

- **HTTP requests**: Bun's `fetch` is built on native code, not `undici` polyfills
- **File I/O**: `Bun.write()` uses optimized syscalls
- **Buffer handling**: Native `Buffer` implementation is faster than Node's

For CPU-bound work, the difference is smaller — both V8 (Node) and JavaScriptCore (Bun) are excellent JIT compilers. But for the kind of tooling and scripting work that most modules do? Bun wins handily.

## The Preset Pattern — Reusability Done Right

One design pattern I love in this module is how it handles style customization through presets and system prompts:

```typescript
// Built-in presets for common use cases
import { generateImage } from "image-gen";
await generateImage({ prompt: "...", preset: "tech-blog" });

// Or pass a custom system prompt for full control
import { systemPrompt } from "./image-prompt";
await generateImage({ prompt: "...", systemPrompt });
```

Each project defines its own visual style in a local `image-prompt.ts` file, while the core generation logic stays in the shared module. The module doesn't need to know about every project's aesthetic preferences — it just provides the hooks.

This is the kind of clean separation that Bun's module linking makes trivial. Change the prompt in one project, the module doesn't care. Update the Gemini API logic in the module, all projects benefit immediately.

## Structuring a Reusable Bun Module

Here's the pattern I've settled on:

```
image-gen/
  package.json       # module + types point to .ts files directly
  bin/cli.ts         # CLI entry point with #!/usr/bin/env bun
  src/
    index.ts         # Public API exports
    generate.ts      # Core logic
    types.ts         # TypeScript interfaces
    presets/          # Built-in configurations
  tsconfig.json      # Just for editor support, not for building
```

The key principles:

1. **No build step** — Source files are the distribution
2. **Dual interface** — Works as both CLI (`bin`) and library (`module`)
3. **Type exports** — Consumers get full TypeScript types for free
4. **Preset/plugin pattern** — Shared logic with per-project customization
5. **Minimal dependencies** — This module has exactly ONE dependency (`@google/genai`)

## Making the Switch

If you're still on Node and you're building internal tools, CLIs, or utility modules, here's my honest take:

**Switch to Bun for tooling.** Keep Node for production servers if your infrastructure demands it, but for everything else — scripts, CLIs, dev tools, local modules — Bun is objectively better DX.

The things you won't miss:
- `tsconfig.json` tweaking for module resolution
- Build steps for TypeScript
- `npm link` breaking randomly
- Waiting 10 seconds for a script to start
- The `type: "module"` vs `"commonjs"` saga

The things you'll gain:
- Write TypeScript, run TypeScript — no transpilation
- Sub-10ms startup for scripts and CLIs
- `bun link` that actually works
- A package manager that respects your time
- Native APIs (`Bun.write`, `Bun.file`, `Bun.serve`) that feel modern

## Try It Yourself

Want to build your own reusable Bun module? Start here:

```bash
mkdir my-module && cd my-module
bun init
```

Add a `bin` field, write your TypeScript, `bun link` it into another project, and you're done. No boilerplate. No ceremony. Just code.

The full `image-gen` module I walked through is about 90 lines of actual logic across 4 files. It handles AI image generation with configurable styles, works as both a CLI and a library, supports multiple aspect ratios and presets — and it took about 20 minutes to write. That's the Bun difference.

*Keep building, keep shipping, and stop wasting time on build tooling that should've been solved a decade ago.*
